"""Ghidra P-Code lifter for CLAUSTRUM.

P-Code provides the broadest architecture coverage through Ghidra's SLEIGH
processor specifications, supporting 30+ ISAs including exotic targets.

Requires: pip install pyhidra
Also requires Ghidra installation with GHIDRA_INSTALL_DIR environment variable.
"""

from __future__ import annotations

import os
import tempfile
from dataclasses import dataclass
from pathlib import Path
from typing import Optional, Any, Dict, List

from claustrum.lifting.base import (
    IRLifter,
    LiftedFunction,
    LiftedBlock,
    IRInstruction,
    IROpcode,
    IROperand,
    LiftingError,
)


# P-Code opcode to unified IR mapping
PCODE_TO_IR_OPCODE: Dict[str, IROpcode] = {
    # Integer arithmetic
    "INT_ADD": IROpcode.ADD,
    "INT_SUB": IROpcode.SUB,
    "INT_MULT": IROpcode.MUL,
    "INT_DIV": IROpcode.DIV,
    "INT_SDIV": IROpcode.SDIV,
    "INT_REM": IROpcode.MOD,
    "INT_SREM": IROpcode.SMOD,
    "INT_NEGATE": IROpcode.NEG,
    
    # Bitwise operations
    "INT_AND": IROpcode.AND,
    "INT_OR": IROpcode.OR,
    "INT_XOR": IROpcode.XOR,
    "INT_LEFT": IROpcode.SHL,
    "INT_RIGHT": IROpcode.SHR,
    "INT_SRIGHT": IROpcode.SAR,
    "INT_2COMP": IROpcode.NEG,
    
    # Comparisons
    "INT_EQUAL": IROpcode.CMP_EQ,
    "INT_NOTEQUAL": IROpcode.CMP_NE,
    "INT_SLESS": IROpcode.CMP_LT,
    "INT_SLESSEQUAL": IROpcode.CMP_LE,
    "INT_LESS": IROpcode.CMP_ULT,
    "INT_LESSEQUAL": IROpcode.CMP_ULE,
    
    # Memory
    "LOAD": IROpcode.LOAD,
    "STORE": IROpcode.STORE,
    
    # Control flow
    "BRANCH": IROpcode.JUMP,
    "CBRANCH": IROpcode.BRANCH,
    "BRANCHIND": IROpcode.JUMP,
    "CALL": IROpcode.CALL,
    "CALLIND": IROpcode.CALL,
    "RETURN": IROpcode.RET,
    
    # Data movement / casting
    "COPY": IROpcode.MOV,
    "INT_ZEXT": IROpcode.ZEXT,
    "INT_SEXT": IROpcode.SEXT,
    "PIECE": IROpcode.MOV,  # Concatenation
    "SUBPIECE": IROpcode.TRUNC,
    
    # Floating point
    "FLOAT_ADD": IROpcode.FADD,
    "FLOAT_SUB": IROpcode.FSUB,
    "FLOAT_MULT": IROpcode.FMUL,
    "FLOAT_DIV": IROpcode.FDIV,
    "FLOAT_EQUAL": IROpcode.FCMP,
    "FLOAT_NOTEQUAL": IROpcode.FCMP,
    "FLOAT_LESS": IROpcode.FCMP,
    "FLOAT_LESSEQUAL": IROpcode.FCMP,
    "INT2FLOAT": IROpcode.FCVT,
    "FLOAT2INT": IROpcode.FCVT,
    "FLOAT2FLOAT": IROpcode.FCVT,
    
    # Boolean
    "BOOL_NEGATE": IROpcode.NOT,
    "BOOL_AND": IROpcode.AND,
    "BOOL_OR": IROpcode.OR,
    "BOOL_XOR": IROpcode.XOR,
    
    # Misc
    "MULTIEQUAL": IROpcode.PHI,  # SSA phi
    "INDIRECT": IROpcode.MOV,
    "PTRADD": IROpcode.ADD,
    "PTRSUB": IROpcode.SUB,
    "CAST": IROpcode.MOV,
}


@dataclass
class PCodeOp:
    """Representation of a single P-Code operation."""
    mnemonic: str
    seq_num: int
    address: int
    output: Optional[Dict[str, Any]] = None
    inputs: Optional[List[Dict[str, Any]]] = None
    
    def __post_init__(self) -> None:
        if self.inputs is None:
            self.inputs = []


class PCodeLifter(IRLifter):
    """Lifter using Ghidra's P-Code IR.
    
    P-Code (Pcode) is Ghidra's intermediate language, generated by the
    SLEIGH processor specifications. It provides:
    - Broadest architecture coverage (30+ ISAs)
    - Consistent semantics across architectures
    - Well-defined register and memory modeling
    
    Args:
        ghidra_path: Path to Ghidra installation (or GHIDRA_INSTALL_DIR env var)
        analyze: Whether to run Ghidra analysis (slower but more accurate)
    """
    
    # Comprehensive ISA support through SLEIGH
    SUPPORTED_ISAS = {
        # Tier 1: Common architectures
        "x86", "x86_64", "arm32", "arm64", "aarch64",
        "mips32", "mips64", "mipsle", "mips64le",
        "ppc32", "ppc64", "powerpc",
        "riscv32", "riscv64",
        
        # Tier 2: Less common but supported
        "sparc32", "sparc64",
        "s390x", "systemz",
        "sh4", "superh",
        "m68k", "68000",
        
        # Tier 3: Embedded and exotic
        "avr", "avr8",
        "msp430",
        "pic16", "pic18", "pic24",
        "8051", "mcs51",
        "tricore",
        "v850",
        "rl78",
        "cr16",
        "hexagon",
        "xtensa",
        "dalvik", "dex",
        
        # Additional
        "6502",
        "z80",
        "8085",
        "hcs08", "hcs12",
        "coldfire",
        "pa-risc", "hppa",
    }
    
    def __init__(
        self,
        ghidra_path: Optional[str] = None,
        analyze: bool = True,
    ):
        super().__init__()
        self.name = "pcode"
        self.supported_isas = self.SUPPORTED_ISAS
        
        self.ghidra_path = ghidra_path or os.environ.get("GHIDRA_INSTALL_DIR")
        self.analyze = analyze
        
        self._pyhidra = None
        self._initialized = False
        
    def _ensure_initialized(self) -> None:
        """Lazily initialize pyhidra."""
        if self._initialized:
            return
            
        try:
            import pyhidra
            
            if self.ghidra_path:
                pyhidra.start(self.ghidra_path)
            else:
                pyhidra.start()
                
            self._pyhidra = pyhidra
            self._initialized = True
            
        except ImportError:
            raise LiftingError(
                "pyhidra not installed. Install with: pip install pyhidra",
                backend="pcode",
            )
        except Exception as e:
            raise LiftingError(
                f"Failed to initialize Ghidra: {e}",
                backend="pcode",
            )
            
    def lift_function(
        self,
        binary_path: Path,
        function_addr: int,
        function_size: Optional[int] = None,
    ) -> LiftedFunction:
        """Lift a function to P-Code IR.
        
        Args:
            binary_path: Path to binary file
            function_addr: Function start address
            function_size: Optional size hint
            
        Returns:
            LiftedFunction with P-Code converted to unified IR
        """
        self._ensure_initialized()
        
        import time
        start_time = time.time()
        
        # Type narrowing: _pyhidra is guaranteed non-None after _ensure_initialized
        pyhidra = self._pyhidra
        assert pyhidra is not None
        
        try:
            with pyhidra.open_program(str(binary_path), analyze=self.analyze) as flat_api:
                program = flat_api.getCurrentProgram()
                listing = program.getListing()
                
                # Get function at address
                addr_factory = program.getAddressFactory()
                addr = addr_factory.getAddress(hex(function_addr))
                
                func = listing.getFunctionAt(addr)
                if func is None:
                    # Try to create function
                    func_mgr = program.getFunctionManager()
                    func = func_mgr.getFunctionContaining(addr)
                    
                if func is None:
                    raise LiftingError(
                        f"No function found at 0x{function_addr:x}",
                        address=function_addr,
                        backend="pcode",
                    )
                    
                # Get function bounds
                body = func.getBody()
                func_start = body.getMinAddress().getOffset()
                func_end = body.getMaxAddress().getOffset()
                func_size_actual = func_end - func_start
                
                # Lift each block
                blocks: Dict[int, LiftedBlock] = {}
                cfg_edges: List[tuple[int, int]] = []
                
                # Get basic blocks via CodeBlockModel
                from ghidra.program.model.block import BasicBlockModel
                block_model = BasicBlockModel(program)
                code_blocks = block_model.getCodeBlocksContaining(body, None)
                
                while code_blocks.hasNext():
                    code_block = code_blocks.next()
                    block_addr = code_block.getFirstStartAddress().getOffset()
                    
                    # Lift instructions in block
                    lifted_block = self._lift_block_internal(
                        listing, code_block, addr_factory
                    )
                    blocks[block_addr] = lifted_block
                    
                    # Get successors
                    dests = code_block.getDestinations(None)
                    while dests.hasNext():
                        dest = dests.next()
                        dest_addr = dest.getDestinationAddress()
                        if dest_addr is not None:
                            cfg_edges.append((block_addr, dest_addr.getOffset()))
                            lifted_block.successors.append(dest_addr.getOffset())
                            
                lift_time = (time.time() - start_time) * 1000
                
                return LiftedFunction(
                    address=func_start,
                    size=func_size_actual,
                    name=func.getName(),
                    blocks=blocks,
                    entry_block=func_start,
                    cfg_edges=cfg_edges,
                    isa=self._detect_isa(program),
                    lifter_backend="pcode",
                    lift_time_ms=lift_time,
                )
                
        except LiftingError:
            raise
        except Exception as e:
            raise LiftingError(
                f"P-Code lifting failed: {e}",
                address=function_addr,
                backend="pcode",
            )
            
    def _lift_block_internal(
        self,
        listing: Any,
        code_block: Any,
        addr_factory: Any,
    ) -> LiftedBlock:
        """Lift a single code block to IR."""
        block_start = code_block.getFirstStartAddress().getOffset()
        block_end = code_block.getMaxAddress().getOffset()
        
        instructions: List[IRInstruction] = []
        
        # Iterate instructions in block
        addr_set = code_block.getAddresses(True)
        while addr_set.hasNext():
            addr = addr_set.next()
            insn = listing.getInstructionAt(addr)
            
            if insn is None:
                continue
                
            # Get P-Code ops for this instruction
            pcode_ops = insn.getPcode()
            
            for pcode_op in pcode_ops:
                ir_instr = self._convert_pcode_op(pcode_op, insn)
                if ir_instr:
                    instructions.append(ir_instr)
                    
        return LiftedBlock(
            address=block_start,
            size=block_end - block_start + 1,
            instructions=instructions,
        )
        
    def _convert_pcode_op(
        self,
        pcode_op: Any,
        insn: Any,
    ) -> Optional[IRInstruction]:
        """Convert a Ghidra PcodeOp to unified IR instruction."""
        try:
            mnemonic = pcode_op.getMnemonic()
            
            # Map to unified opcode
            ir_opcode = PCODE_TO_IR_OPCODE.get(mnemonic, IROpcode.UNKNOWN)
            
            # Convert output varnode to destination
            output = pcode_op.getOutput()
            dest = self._convert_varnode(output) if output else None
            
            # Convert input varnodes to sources
            src = []
            for i in range(pcode_op.getNumInputs()):
                input_vn = pcode_op.getInput(i)
                if input_vn:
                    operand = self._convert_varnode(input_vn)
                    if operand:
                        src.append(operand)
                        
            return IRInstruction(
                opcode=ir_opcode,
                dest=dest,
                src=src,
                address=insn.getAddress().getOffset(),
                size=insn.getLength(),
                comment=str(insn),
            )
            
        except Exception:
            return None
            
    def _convert_varnode(self, varnode: Any) -> Optional[IROperand]:
        """Convert a Ghidra Varnode to IROperand."""
        if varnode is None:
            return None
            
        try:
            size = varnode.getSize() * 8  # Convert bytes to bits
            
            if varnode.isRegister():
                # Register varnode
                reg = varnode.getHigh()
                if reg:
                    return IROperand.reg(reg.getName(), size)
                else:
                    return IROperand.reg(f"r{varnode.getOffset()}", size)
                    
            elif varnode.isConstant():
                # Constant/immediate
                return IROperand.imm(varnode.getOffset(), size)
                
            elif varnode.isUnique():
                # Temporary
                return IROperand.tmp(varnode.getOffset(), size)
                
            elif varnode.isAddress():
                # Memory address
                return IROperand.mem(offset=varnode.getOffset(), size=size)
                
            else:
                # Fallback
                return IROperand.imm(varnode.getOffset(), size)
                
        except Exception:
            return None
            
    def lift_block(
        self,
        binary_path: Path,
        block_addr: int,
        max_size: int = 4096,
    ) -> LiftedBlock:
        """Lift a single basic block."""
        self._ensure_initialized()
        
        # Type narrowing: _pyhidra is guaranteed non-None after _ensure_initialized
        pyhidra = self._pyhidra
        assert pyhidra is not None
        
        try:
            with pyhidra.open_program(str(binary_path), analyze=self.analyze) as flat_api:
                program = flat_api.getCurrentProgram()
                listing = program.getListing()
                addr_factory = program.getAddressFactory()
                
                addr = addr_factory.getAddress(hex(block_addr))
                
                # Get basic block at address
                from ghidra.program.model.block import BasicBlockModel
                block_model = BasicBlockModel(program)
                code_blocks = block_model.getCodeBlocksContaining(
                    program.getAddressFactory().getAddressSet(addr, addr),
                    None
                )
                
                if code_blocks.hasNext():
                    code_block = code_blocks.next()
                    return self._lift_block_internal(listing, code_block, addr_factory)
                else:
                    raise LiftingError(
                        f"No block at 0x{block_addr:x}",
                        address=block_addr,
                        backend="pcode",
                    )
                    
        except LiftingError:
            raise
        except Exception as e:
            raise LiftingError(
                f"Block lifting failed: {e}",
                address=block_addr,
                backend="pcode",
            )
            
    def lift_bytes(
        self,
        code_bytes: bytes,
        isa: str,
        base_address: int = 0x10000,
    ) -> List[LiftedBlock]:
        """Lift raw bytes to IR.
        
        Creates a temporary file and uses Ghidra's raw binary import.
        
        Args:
            code_bytes: Raw machine code
            isa: Target ISA
            base_address: Base address for code
            
        Returns:
            List of lifted blocks
        """
        self._ensure_initialized()
        
        # Type narrowing: _pyhidra is guaranteed non-None after _ensure_initialized
        pyhidra = self._pyhidra
        assert pyhidra is not None
        
        # Map ISA to Ghidra language ID
        lang_id = self._get_language_id(isa)
        
        # Write bytes to temp file
        with tempfile.NamedTemporaryFile(suffix=".bin", delete=False) as f:
            f.write(code_bytes)
            temp_path = f.name
            
        try:
            with pyhidra.open_program(
                temp_path,
                analyze=False,
                language=lang_id,
            ) as flat_api:
                program = flat_api.getCurrentProgram()
                listing = program.getListing()
                addr_factory = program.getAddressFactory()
                
                # Disassemble
                flat_api.disassemble(addr_factory.getAddress(hex(base_address)))
                
                # Lift all instructions
                blocks = []
                instructions = []
                
                insn_iter = listing.getInstructions(True)
                while insn_iter.hasNext():
                    insn = insn_iter.next()
                    pcode_ops = insn.getPcode()
                    
                    for pcode_op in pcode_ops:
                        ir_instr = self._convert_pcode_op(pcode_op, insn)
                        if ir_instr:
                            instructions.append(ir_instr)
                            
                if instructions:
                    blocks.append(LiftedBlock(
                        address=base_address,
                        size=len(code_bytes),
                        instructions=instructions,
                    ))
                    
                return blocks
                
        finally:
            os.unlink(temp_path)
            
    def _get_language_id(self, isa: str) -> str:
        """Map ISA name to Ghidra language ID."""
        mapping = {
            "x86": "x86:LE:32:default",
            "x86_64": "x86:LE:64:default",
            "arm32": "ARM:LE:32:v8",
            "arm64": "AARCH64:LE:64:v8A",
            "aarch64": "AARCH64:LE:64:v8A",
            "mips32": "MIPS:BE:32:default",
            "mips64": "MIPS:BE:64:default",
            "mipsle": "MIPS:LE:32:default",
            "mips64le": "MIPS:LE:64:default",
            "ppc32": "PowerPC:BE:32:default",
            "ppc64": "PowerPC:BE:64:default",
            "riscv32": "RISCV:LE:32:default",
            "riscv64": "RISCV:LE:64:default",
            "sparc32": "sparc:BE:32:default",
            "sparc64": "sparc:BE:64:default",
            "avr": "avr8:LE:16:default",
            "msp430": "TI_MSP430:LE:16:default",
            "m68k": "68000:BE:32:default",
            "sh4": "SuperH4:LE:32:default",
            "hexagon": "hexagon:LE:32:default",
            "tricore": "tricore:LE:32:default",
            "v850": "V850:LE:32:default",
            "6502": "6502:LE:16:default",
            "z80": "z80:LE:16:default",
            "8051": "8051:BE:16:default",
            "pic16": "PIC-16:LE:16:default",
            "dalvik": "Dalvik:LE:32:default",
        }
        
        return mapping.get(isa.lower(), "x86:LE:64:default")
        
    def _detect_isa(self, program: Any) -> str:
        """Detect ISA from Ghidra program."""
        try:
            lang = program.getLanguage()
            proc = lang.getProcessor().toString().lower()
            size = lang.getLanguageDescription().getSize()
            
            # Map processor name to our ISA names
            if "x86" in proc:
                return "x86_64" if size == 64 else "x86"
            elif "aarch64" in proc:
                return "arm64"
            elif "arm" in proc:
                return "arm64" if size == 64 else "arm32"
            elif "mips" in proc:
                return "mips64" if size == 64 else "mips32"
            elif "powerpc" in proc or "ppc" in proc:
                return "ppc64" if size == 64 else "ppc32"
            elif "riscv" in proc:
                return "riscv64" if size == 64 else "riscv32"
            elif "sparc" in proc:
                return "sparc64" if size == 64 else "sparc32"
            elif "avr" in proc:
                return "avr"
            elif "msp430" in proc:
                return "msp430"
            else:
                return proc
                
        except Exception:
            return "unknown"
            
    def get_priority(self, isa: str) -> int:
        """Get lifting priority for ISA.
        
        P-Code is preferred for exotic architectures where VEX/ESIL
        have limited support.
        """
        isa_lower = isa.lower()
        
        # High priority for architectures P-Code handles best
        high_priority = {
            "avr", "msp430", "pic16", "pic18", "pic24",
            "8051", "tricore", "v850", "hexagon", "dalvik",
            "6502", "z80", "sh4", "superh",
        }
        
        if isa_lower in high_priority:
            return 10
        elif isa_lower in self.supported_isas:
            return 3  # Lower than VEX for common ISAs
        else:
            return 0


def create_pcode_lifter(**kwargs) -> PCodeLifter:
    """Factory function for P-Code lifter."""
    return PCodeLifter(**kwargs)
